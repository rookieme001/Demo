![](https://raw.githubusercontent.com/Lobster-King/AppArticles/master/iOS%20OpenSource/SideTable-Title.jpg)


## 写在前面

在开始我们今天的分享之前，先讲个这两天比较火的段子：
>昨晚做梦梦到我死了；  
>进了阎王殿；  
>阎王爷让我给他的生死薄做个后台管理系统。。。  

![](https://raw.githubusercontent.com/Lobster-King/AppArticles/master/iOS%20OpenSource/duanzi.png)


段子可能引起些许不适😅，但与我们今天分享的内容有关。  

阎王爷用生死薄记录人的生死轮回，而这个“生死薄”与SideTable有异曲同工之妙，SideTable同样肩负着管理、记录对象（Object）生死的重任。  

写本篇文章有个重要的原因就是，网络上大部分关于Runtime文章中涉及SideTable都只是一笔带过，甚至有些文章连SideTable和NSObject的关系都没有理清，浑水摸鱼的成分相当大。基于此，本篇文章我会通过调试Runtime源码，并结合图文叙述的方式来进行讲述。希望通过本篇文章的分享，能够让大家对Runtime或者说对于Objective-C这种语言有个整体的感觉。  

进入正题。本篇文章将会分为3部分。第一部分我会简要的分享一下当前高级语言内存管理的几种方式。第二部分会着重介绍下iOS内存管理方式。第三部分会重点分享SideTable数据结构以及它是怎么贯穿整个Runtime的。

## 高级语言常见内存管理方式

当前高级语言中，内存管理大致分为两大类：  

* 基于引用计数的内存管理方式。
* 基于垃圾回收机制的内存管理方式。
  
##### 基于引用计数的内存管理方式  

以牛喝水举例。

![](https://raw.githubusercontent.com/Lobster-King/AppArticles/master/iOS%20OpenSource/niu.jpg)

1.当第一头牛有喝水需求的时候，牧民需要创建一个盆子并倒满水。（ **盆子的引用计数retainCount由0变为1** ）。

2.当第二头牛来喝水的时候，牧民发现已经有一个盆子了就不需要再创建一个盆子，但是牧民要知道这一个盆子有多少头牛在喝水，因为牧民要在没有牛喝水的时候把盆子撤掉。（ **盆子的引用计数retainCount+1，变成了2** ）。

3.这时候第一头牛已经喝饱了，牧民就把它赶走了。（ **盆子的引用计数retainCount-1，变成了1** ）。

4.第二头牛也喝饱了，牧民同样把它赶走了。（ **盆子的引用计数retainCount-1，变成了0** ）这时候牧民发现已经没有牛在喝水了，于是把盆子撤掉了。

以上就是基于引用计数的内存管理方式。需要维护一个表来统计对象的引用计数（牧民从创建盆子、牛数量增减都要去更新盆子的引用计数）。基于引用计数的内存管理方式存在以下优缺点。

**优点**  

* 查询对象是否可释放时效率高（查询retainCount即可）。
* 将内存管理交给开发人员，自由度更大，更能写出高性能的程序。

**缺点**

* 对于发生循环引用的对象，无法释放。
* 每个对象都需要创建与之对应的引用计数器，会有额外的存储开销。
* 内存泄露率高。（这点在ARC时代有了很大改善）

##### 基于垃圾回收机制的内存管理方式











